from abc import ABC, abstractmethod
from enum import Enum
import json
from typing import Callable, Dict, List, Optional, TypeAlias, Any

from common.errors import SchemaError
from common.function_schema import schema_from_function
from utils import compute_hash, extract_metadata

class Suitability(str, Enum):
    """
    Enumeration of protocol suitability statuses.
    """
    ADEQUATE = 'adequate'
    INADEQUATE = 'inadequate'
    PROBABLY_ADEQUATE = 'probably_adequate'
    PROBABLY_INADEQUATE = 'probably_inadequate'
    UNKNOWN = 'unknown'

class Conversation(ABC):
    """
    Abstract base class representing a conversation.
    """

    @abstractmethod
    def __call__(self, message: str, print_output: bool = True) -> Any:
        """
        Processes a message within the conversation.

        Args:
            message (str): The message to process.
            print_output (bool): Whether to print the response.

        Returns:
            Any: The response generated by processing the message.
        """
        pass

    def close(self) -> None:
        """
        Closes the conversation.

        Returns:
            None
        """
        pass

    def __enter__(self) -> "Conversation":
        """
        Enters the conversation context.

        Returns:
            Conversation: The current conversation instance.
        """
        return self
    
    def __exit__(
        self,
        exc_type: Optional[type],
        exc_value: Optional[BaseException],
        traceback: Optional["TracebackType"]
    ) -> None:
        """
        Exits the conversation context, ensuring closure.

        Args:
            exc_type (Optional[type]): The exception type if an error occurred.
            exc_value (Optional[BaseException]): The exception instance if raised.
            traceback (Optional[TracebackType]): The traceback object.

        Returns:
            None
        """
        self.close()

class Protocol:
    """Represents a protocol document with associated sources and metadata."""

    def __init__(
        self,
        protocol_document: str,
        sources: List[str],
        metadata: Optional[Dict[str, str]]
    ) -> None:
        """Initializes a Protocol.

        Args:
            protocol_document (str): The document detailing the protocol.
            sources (List[str]): Sources where the protocol is referenced.
            metadata (Optional[Dict[str, str]]): Additional metadata for the protocol.
        """
        self.protocol_document = protocol_document
        self.sources = sources

        if metadata is None:
            metadata = extract_metadata(protocol_document)

        self.metadata = metadata

    @property
    def hash(self) -> str:
        """
        Computes and returns the hash of the protocol document.

        Returns:
            str: The computed hash value.
        """
        return compute_hash(self.protocol_document)
    
    def __str__(self) -> str:
        """
        Returns a string representation of the Protocol.

        Returns:
            str: The string representation including hash, sources, metadata, and document.
        """
        return f'Protocol {self.hash}\nSources: {self.sources}\nMetadata: {self.metadata}\n\n{self.protocol_document}\n\n'

class TaskSchema:
    """Defines the schema for a task, including description and input/output schemas."""

    def __init__(
        self,
        description: Optional[str],
        input_schema: Optional[dict],
        output_schema: Optional[dict]
    ):
        """Initializes the TaskSchema.

        Args:
            description (Optional[str]): A description of the task.
            input_schema (Optional[dict]): The JSON schema of the input data.
            output_schema (Optional[dict]): The JSON schema of the output data.
        """
        self.description = description
        self.input_schema = input_schema
        self.input_schema = input_schema
        self.output_schema = output_schema
    
    @staticmethod
    def from_json(json_dict : dict) -> 'TaskSchema':
        """
        Creates a TaskSchema from a JSON dictionary.

        Args:
            json_dict (dict): The JSON dictionary containing task schema details.

        Returns:
            TaskSchema: An instance of TaskSchema based on the provided JSON.
        
        Raises:
            SchemaError: If required fields are missing in the JSON dictionary.
        """
        for field in ['description', 'input', 'output']:
            if field not in json_dict:
                raise SchemaError(f'"{field}" field is required in TaskSchema')
    
        return TaskSchema(json_dict['description'], json_dict['input'], json_dict['output'])
    
    def to_json(self) -> dict:
        """
        Converts the TaskSchema to a JSON dictionary.

        Returns:
            dict: The JSON representation of the TaskSchema.
        """
        return {
            'description': self.description,
            'input': self.input_schema,
            'output': self.output_schema
        }
    
    @staticmethod
    def from_function(
        func: Callable,
        description: Optional[str] = None,
        input_schema: Optional[dict] = None,
        output_schema: Optional[dict] = None
    ) -> 'TaskSchema':
        """
        Creates a TaskSchema from a function, inferring schemas if necessary.

        Args:
            func (Callable): The function to infer the schema from.
            description (Optional[str], optional): A description of the task. Defaults to None.
            input_schema (Optional[dict], optional): The input schema. Defaults to None.
            output_schema (Optional[dict], optional): The output schema. Defaults to None.

        Returns:
            TaskSchema: An instance of TaskSchema based on the function.
        """
        schema = schema_from_function(func)

        if description is None:
            description = schema.get('description', None)

        if input_schema is None:
            input_schema = schema.copy()
            input_schema.pop('returns', None)
            input_schema.pop('description', None)

        if output_schema is None:
            output_schema = schema.get('returns', None)

        return TaskSchema(description, input_schema, output_schema)
    
    @staticmethod
    def from_taskschemalike(task_schema_like : 'TaskSchemaLike') -> 'TaskSchema':
        """
        Converts a TaskSchema-like object into a TaskSchema instance.

        Args:
            task_schema_like (TaskSchemaLike): The TaskSchema-like object to convert.

        Returns:
            TaskSchema: An instance of TaskSchema.
        
        Raises:
            SchemaError: If the input is neither a TaskSchema nor a dictionary.
        """
        if isinstance(task_schema_like, TaskSchema):
            return task_schema_like
        elif isinstance(task_schema_like, dict):
            return TaskSchema.from_json(task_schema_like)
        else:
            raise SchemaError('TaskSchemaLike must be either a TaskSchema or a dict')

    def __str__(self) -> str:
        """
        Returns the JSON string representation of the TaskSchema.

        Returns:
            str: The JSON-formatted string of the TaskSchema.
        """
        return json.dumps(self.to_json(), indent=2)

TaskSchemaLike : TypeAlias = TaskSchema | dict